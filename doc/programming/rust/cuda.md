# cudarc


https://crates.io/crates/cudarc


https://github.com/coreylowman/cudarc

Safe abstractions over:

CUDA driver API
NVRTC API
cuRAND API
cuBLAS API


https://github.com/coreylowman/cudarc/blob/main/examples/07-build-workflow/src/main.rs


Note: working - there is something witth ptx format but other than that looks ok



Relates:

## cuDF from rapids

https://github.com/rapidsai/cudf

https://github.com/rapidsai/cudf/issues/11742


https://docs.rapids.ai/api/cudf/stable/



## rayon support

https://github.com/rayon-rs/rayon/issues/778
 still not?



## RAPIDS

https://github.com/rapidsai

https://github.com/rapidsai/cudf/#contributing


#CubeCL

https://crates.io/crates/cubecl

With CubeCL, you can program your GPU using Rust, taking advantage of zero-cost abstractions to develop maintainable, flexible, and efficient compute kernels. CubeCL currently fully supports functions, generics, and structs, with partial support for traits and type inference. As the project evolves, we anticipate even broader support for Rust language primitives, all while maintaining optimal performance.

Example
Simply annotate functions with the cube attribute to indicate that they should run on the GPU.

```rust
use cubecl::prelude::*;

#[cube(launch_unchecked)]
fn gelu_array<F: Float>(input: &Array<F>, output: &mut Array<F>) {
if ABSOLUTE_POS < input.len() {
output[ABSOLUTE_POS] = gelu_scalar::<F>(input[ABSOLUTE_POS]);
}
}

#[cube]
fn gelu_scalar<F: Float>(x: F) -> F {
x * (F::erf(x / F::sqrt(2.0.into())) + 1.0) / 2.0
}
```
You can then launch the kernel using the autogenerated gelu_array::launch_unchecked function.

```rust
fn launch<R: Runtime>(device: &R::Device) {
let client = R::client(device);
let input = &[-1., 0., 1., 5.];
let output_handle = client.empty(input.len() * core::mem::size_of::<f32>());
let input_handle = client.create(f32::as_bytes(input));

    unsafe {
        gelu_array::launch_unchecked::<F32, R>(
            &client,
            CubeCount::Static(1, 1, 1),
            CubeDim::new(input.len() as u32, 1, 1),
            ArrayArg::from_raw_parts(&input_handle, input.len(), 1),
            ArrayArg::from_raw_parts(&output_handle, input.len(), 1),
        )
    };

    let bytes = client.read(output_handle.binding());
    let output = f32::from_bytes(&bytes);

    // Should be [-0.1587,  0.0000,  0.8413,  5.0000]
    println!("Executed gelu with runtime {:?} => {output:?}", R::name());
}

fn main() {
launch::<cubecl::cuda::CudaRuntime>(&Default::default());
launch::<cubecl::wgpu::WgpuRuntime>(&Default::default());
}
```
To see it in action, run the working GELU example with the following command:


```shell
cargo run --example gelu --features cuda # cuda runtime
cargo run --example gelu --features wgpu # wgpu runtime
```

